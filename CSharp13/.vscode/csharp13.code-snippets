{
  "0010-bubble-sort": {
    "prefix": "cs",
    "body": [
      "void BubbleSort<T>(T[] list) where T : IComparable",
      "        {",
      "            bool madeChanges;",
      "            int itemCount = list.Length;",
      "            do",
      "            {",
      "                madeChanges = false;",
      "                itemCount--;",
      "                for (int i = 0; i < itemCount; i++)",
      "                {",
      "                    if (list[i].CompareTo(list[i + 1]) > 0)",
      "                    {",
      "                        T temp = list[i + 1];",
      "                        list[i + 1] = list[i];",
      "                        list[i] = temp;",
      "                        madeChanges = true;",
      "                    }",
      "                }",
      "            } while (madeChanges);",
      "        }",
      ""
    ]
  },
  "0020-use-bubble-sort": {
    "prefix": "cs",
    "body": [
      "        // The problem:",
      "        // We have a list of numbers and want to sort them",
      "        byte[] numbers = [55, 34, 21, 13, 8, 5, 3, 2, 1];",
      "        BubbleSort(numbers);",
      "        Console.WriteLine(string.Join(",
      ", numbers));",
      "",
      "        // Now we want to sort a part of the array -> we have to copy",
      "        numbers = [55, 34, 21, 13, 8, 5, 3, 2, 1];",
      "        var someNumbers = new byte[numbers.Length - 2];",
      "        for (var i = 1; i < numbers.Length - 1; i++) { someNumbers[i - 1] = numbers[i]; }",
      "        BubbleSort(someNumbers);",
      "        Console.WriteLine(string.Join(",
      ", numbers));",
      ""
    ]
  },
  "0030-span-bubble-sort": {
    "prefix": "cs",
    "body": [
      "        void BubbleSortSpan<T>(scoped Span<T> list) where T : IComparable",
      "        {",
      "            bool madeChanges;",
      "            int itemCount = list.Length;",
      "            do",
      "            {",
      "                madeChanges = false;",
      "                itemCount--;",
      "                for (int i = 0; i < itemCount; i++)",
      "                {",
      "                    if (list[i].CompareTo(list[i + 1]) > 0)",
      "                    {",
      "                        T temp = list[i + 1];",
      "                        list[i + 1] = list[i];",
      "                        list[i] = temp;",
      "                        madeChanges = true;",
      "                    }",
      "                }",
      "            } while (madeChanges);",
      "        }",
      "",
      ""
    ]
  },
  "0040-use-span-sort": {
    "prefix": "cs",
    "body": [
      "        // Span solves our problem",
      "        Span<byte> numbersSpan = [55, 34, 21, 13, 8, 5, 3, 2, 1];",
      "        BubbleSortSpan(numbersSpan[1..^1]);",
      "        foreach (var n in numbersSpan) { Console.Write($\"{n} \"); }",
      ""
    ]
  },
  "0045-span-string": {
    "prefix": "cs",
    "body": [
      "ReadOnlySpan<char> text = \"Temp: 15Â° C\";",
      "text = text[(text.IndexOf(' ') + 1)..];",
      "text = text[..(text.IndexOf(' ') - 1)];",
      "if (int.TryParse(text, out var temperature)) ",
      "{",
      "    Console.WriteLine(temperature);",
      "}"
    ]
  },
  "0050-params-collections": {
    "prefix": "0050-params-collections",
    "body": [
      "using System;",
      "using System.Collections.Generic;",
      "using System.Text;",
      "",
      "// Prior to C# 13, 'params' could only be used with arrays.",
      "// So, we could write:",
      "PrintNumbersArray(1, 2, 3, 4, 5);",
      "",
      "// But we could not use 'params' with other collection types like List<T> or Span<T>.",
      "// The following lines would cause compilation errors in previous C# versions:",
      "// PrintNumbersList(1, 2, 3, 4, 5);",
      "// PrintNumbersSpan(1, 2, 3, 4, 5);",
      "",
      "// With C# 13's 'params collections' feature, we can now use 'params' with List<int>:",
      "PrintNumbersList(1, 2, 3, 4, 5);",
      "",
      "// Similarly, we can use 'params' with IEnumerable<int>:",
      "PrintNumbersEnumerable(1, 2, 3, 4, 5);",
      "",
      "// And we can use 'params' with Span<int> for performance benefits:",
      "PrintNumbersSpan(1, 2, 3, 4, 5);",
      "",
      "// We can also use 'params' with ReadOnlySpan<int>:",
      "PrintNumbersReadOnlySpan(1, 2, 3, 4, 5);",
      "// This is particularly interesting for performance reasons. Look at the generated IL code",
      "// (e.g. with dnSpyEx) to see how it works.",
      "",
      "// Using 'params' with an array (possible in all C# versions)",
      "static void PrintNumbersArray(params int[] numbers)",
      "{",
      "    Console.WriteLine(\"PrintNumbersArray:\");",
      "    foreach (var number in numbers)",
      "    {",
      "        Console.WriteLine(number);",
      "    }",
      "    Console.WriteLine();",
      "}",
      "",
      "// Using 'params' with List<int> (new in C# 13)",
      "// This was not possible in previous C# versions",
      "static void PrintNumbersList(params List<int> numbers)",
      "{",
      "    Console.WriteLine(\"PrintNumbersList (List<int>):\");",
      "    // The 'numbers' parameter is a single List<int> constructed from the arguments",
      "    foreach (var number in numbers)",
      "    {",
      "        Console.WriteLine(number);",
      "    }",
      "    Console.WriteLine();",
      "}",
      "",
      "// Using 'params' with IEnumerable<int> (new in C# 13)",
      "// This allows flexibility in the type of collection used",
      "static void PrintNumbersEnumerable(params IEnumerable<int> numbers)",
      "{",
      "    Console.WriteLine(\"PrintNumbersEnumerable (IEnumerable<int>):\");",
      "    foreach (var number in numbers)",
      "    {",
      "        Console.WriteLine(number);",
      "    }",
      "    Console.WriteLine();",
      "}",
      "",
      "// Using 'params' with Span<int> (new in C# 13)",
      "// Offers performance benefits by avoiding heap allocations",
      "static void PrintNumbersSpan(params Span<int> numbers)",
      "{",
      "    Console.WriteLine(\"PrintNumbersSpan (Span<int>):\");",
      "    foreach (var number in numbers)",
      "    {",
      "        Console.WriteLine(number);",
      "    }",
      "    Console.WriteLine();",
      "}",
      "",
      "// Using 'params' with ReadOnlySpan<int> (new in C# 13)",
      "// Useful for read-only operations with performance gains",
      "static void PrintNumbersReadOnlySpan(params ReadOnlySpan<int> numbers)",
      "{",
      "    Console.WriteLine(\"PrintNumbersReadOnlySpan (ReadOnlySpan<int>):\");",
      "    foreach (var number in numbers)",
      "    {",
      "        Console.WriteLine(number);",
      "    }",
      "    Console.WriteLine();",
      "}",
      "",
      ""
    ]
  },
  "0060-ttt-winner-logic": {
    "prefix": "cs",
    "body": [
      "readonly ref struct TicTacToeBoardWithSpans(Span<char> board)",
      "{",
      "    private readonly Span<char> board = board;",
      "",
      "    public readonly ref char this[(int row, int column) index] => ref board[index.row * 3 + index.column];",
      "",
      "    public readonly char GetWinner()",
      "    {",
      "        if (board[0] != ' ' && board[0] == board[1] && board[1] == board[2]) return board[0];",
      "        if (board[3] != ' ' && board[3] == board[4] && board[4] == board[5]) return board[3];",
      "        if (board[6] != ' ' && board[6] == board[7] && board[7] == board[8]) return board[6];",
      "        if (board[0] != ' ' && board[0] == board[3] && board[3] == board[6]) return board[0];",
      "        if (board[1] != ' ' && board[1] == board[4] && board[4] == board[7]) return board[1];",
      "        if (board[2] != ' ' && board[2] == board[5] && board[5] == board[8]) return board[2];",
      "        if (board[0] != ' ' && board[0] == board[4] && board[4] == board[8]) return board[0];",
      "        if (board[2] != ' ' && board[2] == board[4] && board[4] == board[6]) return board[2];",
      "        return ' ';",
      "    }",
      "}",
      ""
    ]
  },
  "0070-ttt-apply-moves": {
    "prefix": "cs",
    "body": [
      "Memory<char> boardSpan = new char[] { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };",
      "var moves = new[] { (0, 0, 'X'), (1, 1, 'O'), (0, 1, 'X'), (1, 0, 'O'), (0, 2, 'X') };",
      "foreach (var hasWinner in ApplyTicTacToeMovesWithSpans(boardSpan, moves))",
      "{",
      "    Console.WriteLine(hasWinner);",
      "}",
      "",
      "static IEnumerable<bool> ApplyTicTacToeMovesWithSpans(/*Span<char>*/ Memory<char> board, (int row, int column, char player)[] moves)",
      "{",
      "    // Creating a new TicTacToeBoardWithSpans here does NOT work because it would be",
      "    // preserved across yield boundaries. This is not allowed for ref structs and/or ref variables.",
      "    //var ttt = new TicTacToeBoardWithSpans(board.Span);",
      "    foreach (var (row, column, player) in moves)",
      "    {",
      "        // We can create the TicTacToeBoardWithSpans instance here.",
      "        //",
      "        // However, board cannot be a Span<char> because it would be preserved across yield boundaries.",
      "        // So we use Memory<char> instead. However, that means that we cannot put the",
      "        // board content on the stack.",
      "        //",
      "        // Note that we can work with ref and the ref struct here :-)",
      "        // Even if you do not write your own ref structs, you will benefit because",
      "        // starting with C# 13, you can use spans in more places!",
      "        var ttt = new TicTacToeBoardWithSpans(board.Span);",
      "        ref var field = ref ttt[(row, column)];",
      "        field = player;",
      "        yield return ttt.GetWinner() != ' ';",
      "    }",
      "}"
    ]
  },
  "0080-ttt-board-array": {
    "prefix": "cs",
    "body": [
      "// Implement a simple TTT board",
      "// We do NOT store the board's data ourselves. Instead, we store a reference to the board's data",
      "struct TicTacToeBoard(char[] board)",
      "{",
      "    // We support indexing the board using a tuple",
      "    public readonly ref char this[(int row, int column) index] => ref board[index.row * 3 + index.column];",
      "",
      "    // We also can do winner detection",
      "    public readonly char GetWinner()",
      "    {",
      "        if (board[0] != ' ' && board[0] == board[1] && board[1] == board[2]) return board[0];",
      "        if (board[3] != ' ' && board[3] == board[4] && board[4] == board[5]) return board[3];",
      "        if (board[6] != ' ' && board[6] == board[7] && board[7] == board[8]) return board[6];",
      "        if (board[0] != ' ' && board[0] == board[3] && board[3] == board[6]) return board[0];",
      "        if (board[1] != ' ' && board[1] == board[4] && board[4] == board[7]) return board[1];",
      "        if (board[2] != ' ' && board[2] == board[5] && board[5] == board[8]) return board[2];",
      "        if (board[0] != ' ' && board[0] == board[4] && board[4] == board[8]) return board[0];",
      "        if (board[2] != ' ' && board[2] == board[4] && board[4] == board[6]) return board[2];",
      "        return ' ';",
      "    }",
      "}"
    ]
  },
  "0090-async-ref": {
    "prefix": "cs",
    "body": [
      "static async Task<char[]> GetTTTBoardAsync()",
      "{",
      "    await Task.Delay(100);",
      "    return [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '];",
      "}",
      "",
      "var board = await GetTTTBoardAsync();",
      "var ttt = new TicTacToeBoard(board);",
      "var moves = new[] { (0, 0, 'X'), (1, 1, 'O'), (0, 1, 'X'), (1, 0, 'O'), (0, 2, 'X') };",
      "foreach (var (row, column, player) in moves)",
      "{",
      "    // This is allowed starting in C# 13. Previoulsy, by-ref locals variables",
      "    // were not allowed in async methods (try it at https://dotnetfiddle.net/zBBB1K).",
      "    ref var field = ref ttt[(row, column)];",
      "    field = player;",
      "    await Task.Delay(100);",
      "}",
      "",
      "Console.WriteLine(ttt.GetWinner());"
    ]
  },
  "0100-ref-with-interface": {
    "prefix": "cs",
    "body": [
      "// In C# 13, generic types can explicitly allow ref structs.",
      "// The compiler enforces ref safety rules.",
      "interface IAddable<T> where T : allows ref struct",
      "{",
      "    static abstract T Add(T left, T right);",
      "}",
      "",
      "// In C# 13, ref structs can implement interfaces.",
      "ref struct Vector2(float x, float y) : IAddable<Vector2>",
      "{",
      "    public float X = x;",
      "    public float Y = y;",
      "",
      "    public static Vector2 Add(Vector2 left, Vector2 right) => new(left.X + right.X, left.Y + right.Y);",
      "}"
    ]
  },
  "0110-use-ref-with-interface": {
    "prefix": "cs",
    "body": [
      "Vector2 v1 = new(1, 2);",
      "// var addable = v1 as IAddable<Vector2>; // This is not allowed as it would lead to boxing.",
      "Vector2 v2 = new(3, 4);",
      "Vector2 v3 = Vector2.Add(v1, v2);",
      "",
      "Console.WriteLine($\"{v3.X}, {v3.Y}\");"
    ]
  },
  "0120-ref-struct-with-interface": {
    "prefix": "cs",
    "body": [
      "interface IHaveLength",
      "{",
      "    float GetLength();",
      "}",
      "",
      "// ref struct implementing interface is new in C# 13.",
      "ref struct Vector2(float x, float y) : IHaveLength",
      "{",
      "    public float X = x;",
      "    public float Y = y;",
      "",
      "    public float GetLength() => MathF.Sqrt(X * X + Y * Y);",
      "}"
    ]
  },
  "0130-allows-ref-struct": {
    "prefix": "cs",
    "body": [
      "class Aggregator<T> where T: IHaveLength, allows ref struct {",
      "    public float TotalLength { get; private set; }",
      "",
      "    public void Add(T item) => TotalLength += item.GetLength();",
      "}"
    ]
  },
  "0140-use-aggregator": {
    "prefix": "cs",
    "body": [
      "var agg = new Aggregator<Vector2>();",
      "agg.Add(new Vector2(1, 2));",
      "agg.Add(new Vector2(3, 4));",
      "",
      "Console.WriteLine(agg.TotalLength);"
    ]
  },
  "0150-spans-in-std": {
    "prefix": "",
    "body": [
      "// New in .NET 9: File helpers supporting spans",
      "using System.Text.RegularExpressions;",
      "",
      "ReadOnlySpan<char> text = stackalloc char[] { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };",
      "File.WriteAllText(\"hello.txt\", text);",
      "Console.WriteLine($\"\\t{File.ReadAllText(\"hello.txt\")}\");",
      "File.Delete(\"hello.txt\");",
      "",
      "// Lots of string functions support Spans",
      "ReadOnlySpan<char> part1 = stackalloc char[] { 'H', 'e', 'l', 'l', 'o' };",
      "ReadOnlySpan<char> separator = stackalloc char[] { ' ' };",
      "ReadOnlySpan<char> part2 = stackalloc char[] { 'W', 'o', 'r', 'l', 'd' };",
      "Console.WriteLine($\"\\t{string.Concat(part1, separator, part2)}\");",
      "",
      "ReadOnlySpan<string?> parts = [ \"Hello\", \"World\" ];",
      "Console.WriteLine($\"\\t{string.Join(\", \", parts)}\");",
      "",
      "// The MemoryExtensions class provides tons of useful extension methods",
      "// for spans and memory. Take the time to study them! Here is an example",
      "// of a brand new extension method for splitting a span.",
      "// https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.split?view=net-9.0#system-memoryextensions-split-1(system-readonlyspan((-0))-0)",
      "ReadOnlySpan<char> data = \"25Â° C;36Â° F;16Â° C\";",
      "var regex = new Regex(@\"\\d+Â°\"); // Note: Use GeneratedRegex attribute in practice to speed up regex",
      "                                //       Here, we focus on spans, not regex -> we keep it simple",
      "foreach (var segmentRange in data.Split(';'))",
      "{",
      "    var segment = data[segmentRange];",
      "    int? degrees = null;",
      "    foreach(var match in regex.EnumerateMatches(segment))",
      "    {",
      "        var value = segment[match.Index..(match.Index + match.Length)];",
      "        degrees ??= int.Parse(value[..^1]);",
      "    }",
      "",
      "    Console.WriteLine($\"\\t{segmentRange.Start} - {segmentRange.End}: {segment} -> {degrees}\");",
      "}",
      "",
      "// Here is another new extension method for span that checks if a span starts with a given value.",
      "ReadOnlySpan<int> numbers = stackalloc int[] { 1, 2, 3, 4, 5 };",
      "Console.WriteLine($\"\\tDoes it start with 1? {numbers.StartsWith(1)}\");"
    ]
  },
  "0160-traditional-lock-object": {
    "prefix": "cs",
    "body": [
      "class StampCollection",
      "{",
      "    // A list to hold the collection of stamps.",
      "    private List<string> Collection { get; } = [];",
      "",
      "    // A dedicated object used for locking to ensure thread safety.",
      "    private readonly object lockObject = new();",
      "",
      "    // Method to add a stamp to the collection using the 'lock' keyword.",
      "    public void AddStamp(string stamp)",
      "    {",
      "        // The lock keyword in C# is a shorthand for acquiring and releasing a lock on a specified object. ",
      "        // It ensures that only one thread can execute the code block at a time, providing thread safety. ",
      "        // When a thread enters a lock block, it acquires an exclusive lock on the specified object",
      "        // (lockObject in this case). The lock is automatically released when the thread exits the block, ",
      "        // even if an exception occurs.",
      "        //",
      "        // Using a dedicated lock object (lockObject) is a common practice because it avoids potential ",
      "        // deadlocks and ensures that the lock is only used for synchronization purposes. Locking on this ",
      "        // or other publicly accessible objects can lead to complex and hard-to-debug issues, as other ",
      "        // code might inadvertently lock on the same object.",
      "        lock (lockObject)",
      "        {",
      "            Collection.Add(stamp);",
      "        }",
      "    }",
      "",
      "    // Method to add a stamp to the collection manually using Monitor.Enter and Monitor.Exit.",
      "    public void AddStampManually(string stamp)",
      "    {",
      "        bool lockTaken = false;",
      "        try",
      "        {",
      "            // Monitor.Enter is used to acquire an exclusive lock on the specified object (lockObject).",
      "            // The 'ref lockTaken' parameter indicates whether the lock was successfully taken.",
      "            Monitor.Enter(lockObject, ref lockTaken);",
      "            Collection.Add(stamp);",
      "        }",
      "        finally",
      "        {",
      "            // If the lock was successfully taken, Monitor.Exit is called to release the lock.",
      "            if (lockTaken)",
      "            {",
      "                Monitor.Exit(lockObject);",
      "            }",
      "        }",
      "    }",
      "}"
    ]
  },
  "0170-new-lock-object": {
    "prefix": "cs",
    "body": [
      "class NewStampCollection",
      "{",
      "    private List<string> Collection { get; } = [];",
      "",
      "    // Here we use the new Lock lock object of .NET 9.",
      "    private readonly Lock lockObject = new();",
      "",
      "    public void AddStamp(string stamp)",
      "    {",
      "        // The lock keyword understands the new lock object.",
      "        lock (lockObject)",
      "        {",
      "            Collection.Add(stamp);",
      "        }",
      "",
      "        // Will lead to:",
      "        //using(lockObject.EnterScope())",
      "        //{",
      "        //    Collection.Add(stamp);",
      "        //}",
      "    }",
      "",
      "    public void AddStampManually(string stamp)",
      "    {",
      "        lockObject.Enter(); // Will wait until the lock is available.",
      "                            // In a Windows STA thread (e.g. a GUI thread), other code in the same thread can still run.",
      "        try",
      "        {",
      "            Collection.Add(stamp);",
      "        }",
      "        finally",
      "        {",
      "            lockObject.Exit();",
      "        }",
      "    }",
      "",
      "    public bool TryAddStamp(string stamp)",
      "    {",
      "        if (lockObject.TryEnter())",
      "        {",
      "            try",
      "            {",
      "                Collection.Add(stamp);",
      "                return true;",
      "            }",
      "            finally",
      "            {",
      "                lockObject.Exit();",
      "            }",
      "        }",
      "",
      "        return false;",
      "    }",
      "}",
      ""
    ]
  },
  "0180-use-lock-objects": {
    "prefix": "cs",
    "body": [
      "var collection = new StampCollection();",
      "collection.AddStamp(\"Penny Black\");",
      "collection.AddStampManually(\"Blue Mauritius\");",
      "",
      "var newCollection = new NewStampCollection();",
      "newCollection.AddStamp(\"Baden 9 Kreuzer\");",
      "newCollection.AddStampManually(\"Inverted Jenny\");",
      "if (newCollection.TryAddStamp(\"The Penny Red\"))",
      "{",
      "    Console.WriteLine(\"Stamp added\");",
      "}"
    ]
  },
  "0190-partial-props": {
    "prefix": "cs",
    "body": [
      "// UserCode.cs",
      "using System.ComponentModel;",
      "",
      "var vm = new ViewModel();",
      "vm.UserName = \"John Doe\";",
      "Console.WriteLine(vm.UserName);",
      "",
      "vm[\"UserName\"] = \"Jane Doe\";",
      "Console.WriteLine(vm.UserName);",
      "",
      "public partial class ViewModel : INotifyPropertyChanged",
      "{",
      "    public event PropertyChangedEventHandler? PropertyChanged;",
      "",
      "    // Partial properties are new in C# 13. They are particularly useful for code generation.",
      "    public partial string UserName { get; set; }",
      "",
      "    // Partial indexers are also new in C# 13.",
      "    public partial object? this[string propertyName] { get; set; }",
      "}",
      "",
      "// Generated.cs",
      "public partial class ViewModel",
      "{",
      "    private string __generated_userName = \"\";",
      "",
      "    public partial string UserName",
      "    {",
      "        get => __generated_userName;",
      "        set",
      "        {",
      "            if (value != __generated_userName) {",
      "                __generated_userName = value;",
      "                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(UserName)));",
      "            }",
      "        }",
      "    }",
      "",
      "    public partial object? this[string propertyName]",
      "    {",
      "        get",
      "        {",
      "            // Use reflection to get the property value",
      "            var propertyInfo = this.GetType().GetProperty(propertyName);",
      "            return propertyInfo?.GetValue(this);",
      "        }",
      "        set",
      "        {",
      "            // Use reflection to set the property value",
      "            var propertyInfo = this.GetType().GetProperty(propertyName);",
      "            propertyInfo?.SetValue(this, value);",
      "        }",
      "    }",
      "}"
    ]
  },
  "0200-prop-types": {
    "prefix": "cs",
    "body": [
      "var p = new Properties",
      "{",
      "    ManualProp = \"\",",
      "    AutoProp = \"\",",
      "    AutoInitOnlyProp = \"\",",
      "    RequiredProp = \"\",",
      "};",
      "",
      "class Properties",
      "{",
      "    private string? ManualPropValue;",
      "    public string? ManualProp",
      "    {",
      "        get => ManualPropValue;",
      "        set => ManualPropValue = value;",
      "    }",
      "    ",
      "    public string? AutoProp { get; set; } = \"\";",
      "    public string AutoReadOnlyProp { get; } = \"\"; // Can be assigned in ctor",
      "    public string? AutoInitOnlyProp { get; init; }",
      "",
      "    public required string RequiredProp { get; set; }",
      "    ",
      "    public string ExpressionBodiedProp => \"\";",
      "}",
      ""
    ]
  },
  "0210-semi-automated-props": {
    "prefix": "cs",
    "body": [
      "class Vector2d",
      "{",
      "    public double Length { get; set; }",
      "    public double Angle",
      "    {",
      "        get;",
      "        set => field = value * (Math.PI / 180);",
      "               // CAREFUL! This is preview!",
      "    }",
      "}"
    ]
  }
}
